% !TEX program = xelatex
\documentclass[a4paper]{exam}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage[left=1.8cm,right=1.8cm,top=2.2cm,bottom=2.0cm]{geometry}
\usepackage[UTF8]{ctex}
\usepackage{enumerate}
\usepackage{fancyhdr}
\usepackage{xpatch}
\usepackage{graphicx} 
\usepackage{float} 
\usepackage{subfigure} 
\usepackage{amsfonts}
\usepackage{mathtools}
\usepackage{framed}
\usepackage{multicol}
\usepackage{minted}
\usepackage{fontspec}
\usepackage{float}
\usepackage{tikz}
\usepackage{multicol,comment}
\usepackage{biblatex}
\addbibresource{06-discussion.bib}
\usepackage{tikz}

\usetikzlibrary{automata,positioning}
\theoremstyle{definition}
\newtheorem*{solution*}{\textbf{Solution:}}
\newtheorem*{proof*}{\textbf{Proof:}}
\newtheorem{theorem}{Theorem}[subsection]
\newtheorem{definition}{Definition}[subsection]
\newtheorem{lemma}{Lemma}[subsection]
\makeatletter

\AtBeginDocument{\xpatchcmd{\@thm}{\thm@headpunct{.}}{\thm@headpunct{}}{}{}}
\makeatother

\pagestyle{fancy}
\renewcommand{\baselinestretch}{1.15}

\usepackage{paralist}
\let\itemize\compactitem
\let\enditemize\endcompactitem
\let\enumerate\compactenum
\let\endenumerate\endcompactenum
\let\description\compactdesc
\let\enddescription\endcompactdesc

% shorten footnote rule
\xpatchcmd\footnoterule
  {.4\columnwidth}
  {1in}
  {}{\fail}

\title{CS 131 Compilers: Discussion 6: More on Modern Intermediate Representation}
\author{\textbf{杨易为}~~\textbf{吴凌云}~~\textbf{樊雨鑫} \\ \texttt{ \{yangyw,wuly2,fanyx\}@shanghaitech.edu.cn}}

\begin{document}
\maketitle
\section{Object Oriented Programming}
Recall the $stub$ trick from the lecture, an implementation strategy for multiple inheritance is listed as following:

\begin{verbatim}
class Base {
  public:
    int foo;
    virtual int f() {
      std::cout << this << std::endl; 
      return this->foo;
    }
};

class Base2 {
  public:
     int bar;
     virtual int g() {
      std::cout << this << std::endl; 
      return this->bar;
     }
};

class Derived : public Base, public Base2 {
  public:
     int baz;
     virtual int h() {
       std::cout << this << std::endl; 
       return this->baz;
     }
};
\end{verbatim}

To overcome this issue, compilers will move the this pointer so that each method sees what it expects. For simplicity, they actually create stub methods that will move the this pointer before calling the original method. For example, the compiler may generate

\begin{verbatim}
  Base2::g’() { move_this_pointer(); g(); }
\end{verbatim}

\begin{enumerate}
  \item Roughly sketch the class layout of the above classes (using the same 4-byte offset convention  from  the  inheritance  lecture).   ForDerived,  assumeh()is  storedinside its own version ofBase’s vtable.
  \item What will the following print (assuming there is no padding)?
        \begin{verbatim}
    Derived a;
    std::cout << &a << std::endl; // Suppose this prints 0x10
    a.f();
    a.g();
    a.h();
  \end{verbatim}
\end{enumerate}
\subsubsection{C++ OOP implementation in LLVM IR}

\subsubsection{ChocoPy OOP Mapping on Light IR}
Here's an example of OOP in ChocoPy
\begin{minted}[mathescape, linenos]{python}
class A(object):
    a:int = 42
    def foo(self:"A", ignore:object) -> int:
        return self.a
    def bar(self:"A") -> int:
        print("A")
        return 0
class B(A):
    b:bool = True
    def __init__(self:"B"):
        print("B")
    def bar(self:"B") -> int:
        print("B")
        return 0
class C(B):
    c:bool = True
    def __init__(self:"C"):
        print("C")
    def foo1(self:"C") -> int:
        print("B")
        return 0
    def bar(self:"C") -> int:
        print("C")
        return 0
\end{minted}
The dispatch table will be the following.
\begin{minted}[mathescape, linenos]{llvm}
.globl $A$dispatchTable
$A$dispatchTable:
  .word $object.__init__                   # Implementation for method: A.__init__
  .word $A.foo                             # Implementation for method: A.foo
  .word $A.bar                             # Implementation for method: A.bar

.globl $B$dispatchTable
$B$dispatchTable:
  .word $B.__init__                        # Implementation for method: B.__init__
  .word $A.foo                             # Implementation for method: B.foo
  .word $B.bar                             # Implementation for method: B.bar

.globl $C$dispatchTable
$C$dispatchTable:
  .word $C.__init__                        # Implementation for method: C.__init__
  .word $A.foo                             # Implementation for method: C.foo
  .word $C.bar                             # Implementation for method: C.bar
  .word $C.foo1                            # Implementation for method: C.foo1
\end{minted}

\subsection{Exceptions and Code Generation}
In  this  question  we’ll  look  at  how  the  set\_jmp/long\_jmp  exception  mechanism  can  be  im-plemented.   Consider  a  32-bit  computer  architecture  with  5  registers  (r0,  ...,r4):r0-2are used for function parameters,r3is used for the return address, andr4is used to storethe return value.  Implement set\_jmp(jmp\_buf*)and long\_jmp(jmp\_buf*, int)in assembly(AT\&T syntax).  Assume that the jmp\_buf is large enough, and that the second argument to long\_jmp is never 0.
\begin{solutions}

\end{solutions}
  \begin{enumerate}
    \item  Is it possible to longjmp to the same jmp\_buf multiple times?
    \item  Write a program which throws an exception, handles it, and returns to the exceptionsite from the exception handler using set\_jmp/long\_jmp.
  \end{enumerate}
  \begin{solutions}

  \end{solutions}

\subsection{Basic Optimization on IR}
In GCC or optimization of Java code, we do some genuine optimization like const propogation, in LLVM IR, we literally do them in the IR. Here are the process to do so.

\subsubsection{Mem2Reg}


\subsubsection{SimplifyCFG}
Performs dead code elimination and basic block merging. Specifically:
\begin{enumerate}
  \item Removes basic blocks with no predecessors.
  \item Merges a basic block into its predecessor if there is only one and the predecessor only has one successor.
  \item Eliminates PHI nodes for basic blocks with a single predecessor.
  \item Eliminates a basic block that only contains an unconditional branch.
\end{enumerate}

\begin{minted}[mathescape, linenos]{llvm}
; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -instcombine -simplifycfg -S < %s 

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

; #include <limits>
; #include <cstdint>
;
; using size_type = std::size_t;
; bool will_not_overflow(size_type size, size_type nmemb) {
;   return (size != 0 && (nmemb > std::numeric_limits<size_type>::max() / size));
; }

define i1 @will_not_overflow(i64 %arg, i64 %arg1) {
; SIMPLIFYCFG-LABEL: @will_not_overflow(
;  bb:
;    [[T0:%.*]] = icmp eq i64 [[ARG:%.*]], 0
;    br i1 [[T0]], label [[BB5:%.*]], label [[BB2:%.*]]
;  bb2:
;    [[T3:%.*]] = udiv i64 -1, [[ARG]]
;    [[T4:%.*]] = icmp ult i64 [[T3]], [[ARG1:%.*]]
;    br label [[BB5]]
;  bb5:
;    [[T6:%.*]] = phi i1 [ false, [[BB:%.*]] ], [ [[T4]], [[BB2]] ]
;    ret i1 [[T6]]
;
; INSTCOMBINEONLY-LABEL: @will_not_overflow(
;  bb:
;    [[T0:%.*]] = icmp eq i64 [[ARG:%.*]], 0
;    br i1 [[T0]], label [[BB5:%.*]], label [[BB2:%.*]]
;  bb2:
;    [[UMUL:%.*]] = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 [[ARG]], i64 [[ARG1:%.*]])
;    [[UMUL_OV:%.*]] = extractvalue { i64, i1 } [[UMUL]], 1
;    br label [[BB5]]
;  bb5:
;    [[T6:%.*]] = phi i1 [ false, [[BB:%.*]] ], [ [[UMUL_OV]], [[BB2]] ]
;    ret i1 [[T6]]
;
; INSTCOMBINESIMPLIFYCFGONLY-LABEL: @will_not_overflow(
;  bb:
;    [[T0:%.*]] = icmp eq i64 [[ARG:%.*]], 0
;    [[UMUL:%.*]] = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 [[ARG]], i64 [[ARG1:%.*]])
;    [[UMUL_OV:%.*]] = extractvalue { i64, i1 } [[UMUL]], 1
;    [[T6:%.*]] = select i1 [[T0]], i1 false, i1 [[UMUL_OV]]
;    ret i1 [[T6]]
;
; INSTCOMBINESIMPLIFYCFGINSTCOMBINE-LABEL: @will_not_overflow(
;  bb:
;    [[UMUL:%.*]] = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 [[ARG:%.*]], i64 [[ARG1:%.*]])
;    [[UMUL_OV:%.*]] = extractvalue { i64, i1 } [[UMUL]], 1
;    ret i1 [[UMUL_OV]]
;
; INSTCOMBINESIMPLIFYCFGCOSTLYONLY-LABEL: @will_not_overflow(
;  bb:
;    [[T0:%.*]] = icmp eq i64 [[ARG:%.*]], 0
;    [[UMUL:%.*]] = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 [[ARG]], i64 [[ARG1:%.*]])
;    [[UMUL_OV:%.*]] = extractvalue { i64, i1 } [[UMUL]], 1
;    [[T6:%.*]] = select i1 [[T0]], i1 false, i1 [[UMUL_OV]]
;    ret i1 [[T6]]
;
; INSTCOMBINESIMPLIFYCFGCOSTLYINSTCOMBINE-LABEL: @will_not_overflow(
;  bb:
;    [[UMUL:%.*]] = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 [[ARG:%.*]], i64 [[ARG1:%.*]])
;    [[UMUL_OV:%.*]] = extractvalue { i64, i1 } [[UMUL]], 1
;    ret i1 [[UMUL_OV]]
;
bb:
  %t0 = icmp eq i64 %arg, 0
  br i1 %t0, label %bb5, label %bb2

bb2:                                              ; preds = %bb
  %t3 = udiv i64 -1, %arg
  %t4 = icmp ult i64 %t3, %arg1
  br label %bb5

bb5:                                              ; preds = %bb2, %bb
  %t6 = phi i1 [ false, %bb ], [ %t4, %bb2 ]
  ret i1 %t6
}

; Same as @will_not_overflow, but inverting return value.

define i1 @will_overflow(i64 %arg, i64 %arg1) {
; SIMPLIFYCFG-LABEL: @will_overflow(
;  bb:
;    [[T0:%.*]] = icmp eq i64 [[ARG:%.*]], 0
;    br i1 [[T0]], label [[BB5:%.*]], label [[BB2:%.*]]
;  bb2:
;    [[T3:%.*]] = udiv i64 -1, [[ARG]]
;    [[T4:%.*]] = icmp ult i64 [[T3]], [[ARG1:%.*]]
;    br label [[BB5]]
;  bb5:
;    [[T6:%.*]] = phi i1 [ false, [[BB:%.*]] ], [ [[T4]], [[BB2]] ]
;    [[T7:%.*]] = xor i1 [[T6]], true
;    ret i1 [[T7]]
;
; INSTCOMBINEONLY-LABEL: @will_overflow(
;  bb:
;    [[T0:%.*]] = icmp eq i64 [[ARG:%.*]], 0
;    br i1 [[T0]], label [[BB5:%.*]], label [[BB2:%.*]]
;  bb2:
;    [[UMUL:%.*]] = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 [[ARG]], i64 [[ARG1:%.*]])
;    [[UMUL_OV:%.*]] = extractvalue { i64, i1 } [[UMUL]], 1
;    [[PHITMP:%.*]] = xor i1 [[UMUL_OV]], true
;    br label [[BB5]]
;  bb5:
;    [[T6:%.*]] = phi i1 [ true, [[BB:%.*]] ], [ [[PHITMP]], [[BB2]] ]
;    ret i1 [[T6]]
;
; INSTCOMBINESIMPLIFYCFGONLY-LABEL: @will_overflow(
;  bb:
;    [[T0:%.*]] = icmp eq i64 [[ARG:%.*]], 0
;    [[UMUL:%.*]] = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 [[ARG]], i64 [[ARG1:%.*]])
;    [[UMUL_OV:%.*]] = extractvalue { i64, i1 } [[UMUL]], 1
;    [[PHITMP:%.*]] = xor i1 [[UMUL_OV]], true
;    [[T6:%.*]] = select i1 [[T0]], i1 true, i1 [[PHITMP]]
;    ret i1 [[T6]]
;
; INSTCOMBINESIMPLIFYCFGINSTCOMBINE-LABEL: @will_overflow(
;  bb:
;    [[UMUL:%.*]] = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 [[ARG:%.*]], i64 [[ARG1:%.*]])
;    [[UMUL_OV:%.*]] = extractvalue { i64, i1 } [[UMUL]], 1
;    [[PHITMP:%.*]] = xor i1 [[UMUL_OV]], true
;    ret i1 [[PHITMP]]
;
; INSTCOMBINESIMPLIFYCFGCOSTLYONLY-LABEL: @will_overflow(
;  bb:
;    [[T0:%.*]] = icmp eq i64 [[ARG:%.*]], 0
;    [[UMUL:%.*]] = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 [[ARG]], i64 [[ARG1:%.*]])
;    [[UMUL_OV:%.*]] = extractvalue { i64, i1 } [[UMUL]], 1
;    [[PHITMP:%.*]] = xor i1 [[UMUL_OV]], true
;    [[T6:%.*]] = select i1 [[T0]], i1 true, i1 [[PHITMP]]
;    ret i1 [[T6]]
;
; INSTCOMBINESIMPLIFYCFGCOSTLYINSTCOMBINE-LABEL: @will_overflow(
;  bb:
;    [[UMUL:%.*]] = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 [[ARG:%.*]], i64 [[ARG1:%.*]])
;    [[UMUL_OV:%.*]] = extractvalue { i64, i1 } [[UMUL]], 1
;    [[PHITMP:%.*]] = xor i1 [[UMUL_OV]], true
;    ret i1 [[PHITMP]]
;
bb:
  %t0 = icmp eq i64 %arg, 0
  br i1 %t0, label %bb5, label %bb2

bb2:                                              ; preds = %bb
  %t3 = udiv i64 -1, %arg
  %t4 = icmp ult i64 %t3, %arg1
  br label %bb5

bb5:                                              ; preds = %bb2, %bb
  %t6 = phi i1 [ false, %bb ], [ %t4, %bb2 ]
  %t7 = xor i1 %t6, true
  ret i1 %t7
}
\end{minted}

\printbibliography
\end{document}
