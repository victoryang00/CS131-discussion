% !TEX program = xelatex
\documentclass[a4paper]{article}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage[left=1.8cm,right=1.8cm,top=2.2cm,bottom=2.0cm]{geometry}
\usepackage{ctex}
\usepackage{enumerate}
\usepackage{fancyhdr}
\usepackage{xpatch}
\usepackage{graphicx} 
\usepackage{float} 
\usepackage{subfigure} 
\usepackage{amsfonts}
\usepackage{mathtools}
\usepackage{framed}
\usepackage{multicol}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{tikz}
\usetikzlibrary{automata,positioning}
\theoremstyle{definition}
\newtheorem*{solution*}{\textbf{Solution:}}
\newtheorem*{proof*}{\textbf{Proof:}}
\newtheorem{theorem}{Theorem}[subsection]
\newtheorem{definition}{Definition}[subsection]
\newtheorem{lemma}{Lemma}[subsection]
\makeatletter

\AtBeginDocument{\xpatchcmd{\@thm}{\thm@headpunct{.}}{\thm@headpunct{}}{}{}}
\makeatother

\pagestyle{fancy}
\renewcommand{\baselinestretch}{1.15}

\usepackage{paralist}
\let\itemize\compactitem
\let\enditemize\endcompactitem
\let\enumerate\compactenum
\let\endenumerate\endcompactenum
\let\description\compactdesc
\let\enddescription\endcompactdesc

% shorten footnote rule
\xpatchcmd\footnoterule
  {.4\columnwidth}
  {1in}
  {}{\fail}

\title{CS 131 Compilers: Discussion 4: Syntax-Derivative Tree Scheme}
\author{\textbf{杨易为}~~\textbf{季杨彪}~~\textbf{尤存翰} \\ \texttt{ \{yangyw,jiyb,youch\}@shanghaitech.edu.cn}}


\begin{document}
\maketitle
% \section{DFA and NFA}
% \subsection{Introduction}
\section{LL Parsing Ambiguities}
 An LL(k) grammar is a CFG used by a parser that scans
input left-to-right (“L”), leftmost derivation (“L”), and uses k tokens of lookahead to
predict the correct production. We’ve previously seen that a grammar is ambiguous
if it has a parse tree that is not unique. A more formal definition of LL conflicts uses
FIRST and FOLLOW sets.

\begin{enumerate}
  \item \textbf{FIRST(A)}  the set of all terminals that could occur first in an expansion of
  the terminal or nonterminal A (include $\epsilon$ if A can expand to $\epsilon$)
  \item \textbf{FOLLOW(A)}  the set of all terminals that could follow an occurrence of the
  terminal or nonterminal A in a (partial) derivation.
\end{enumerate}

There are two main types of LL(1) conflicts:
\begin{enumerate}
  \item \textbf{FIRST/FIRST} The FIRST sets of two different productions for same nonterminal intersect.
  \item \textbf{FIRST/FOLLOW}: The FIRST set of a grammar rule contains an epsilon and
  the intersection with its FOLLOW set is not empty.

\end{enumerate}

Is the following grammar LL(1)? Justify your answer using FIRST and FOLLOW sets.
\\
$S → Xd\\  X → C | Ba\\ C →\epsilon \\B → d$

\textbf{Answer:}

\section{Resolving Conflicts}
Consider the following grammar for numerical expressions with division, addition, and
unary minus:

$$E → Num | E/E | E + E | − E$$

\begin{enumerate}
  \item Rewrite the grammar so that it is LL(1), so that ‘/’ has higher precedence than
  ‘+’, and so that ‘-’ has highest precedence. ‘+’ and ‘/’ should be parsed in a
  right-associative way.
  \item  Compute the FIRST and FOLLOW sets for your re-written LL(1) grammar.
  \item Draw the LL(1) parsing table for the grammar. You may need the following rules:
  \begin{enumerate}
    \item  For each production $X \rightarrow A_{1} \ldots A_{n}:$
    \item For each $1 \leq i \leq n,$ and for each $b$ in First $\left(A_{i}\right):$ Set $T[X, b]=X \rightarrow$
    $A_{1} \ldots A_{n} .$ Stop when $\epsilon$ is not in First $\left(A_{i}\right) .$
    \item If $A_{1} \ldots A_{n} \rightarrow^{*} \epsilon,$ then for each $b$ in Follow $(X):$ Set $T[X, b]=\epsilon$
  \end{enumerate}
\end{enumerate}
\textbf{Answer:}

\section{Earley's Algorithm}
Consider the following CFG with terminals $\{(,),+, *, a, b\}$ (+ represents union) that is
used to represent regular expressions over alphabet $\{a, b\}$ :

$$R \rightarrow R+R|R R|(R)\left|R^{*}\right| a \mid b$$
\begin{enumerate}
  \item Using the above CFG, provide a derivation for the following input string $\left(a+(b a)^{*} b\right)^{*}$.
  \item For the derivation in above solution, provide the corresponding parse tree.
\end{enumerate}
\textbf{Answer:}

\end{document}
